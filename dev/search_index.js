var documenterSearchIndex = {"docs":
[{"location":"guide/#","page":"User Guide","title":"User Guide","text":"","category":"page"},{"location":"guide/#Choosing-your-own-prefix-for-trait-types-1","page":"User Guide","title":"Choosing your own prefix for trait types","text":"","category":"section"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"When you define a trait using verbs like Fly or Swim in the above, it makes sense to define trait types with Can and Cannot prefixes.  But, what if you want to define a trait using a noun or an adjective?","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"In that case, you can define your trait with the prefix clause:","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"abstract type Collection end\n@trait Iterable as Collection prefix Is,Not","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"In that case, the following types will be defined instead:","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"IsIterable\nNotIterable","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"This should make your code a lot more readable.","category":"page"},{"location":"guide/#Making-composite-traits-1","page":"User Guide","title":"Making composite traits","text":"","category":"section"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"Sometimes we really want to compose traits and use it directly for dispatch.  In that case, we just need to use the with clause:","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"@trait FlySwim as Ability prefix Can,Cannot with Fly,Swim","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"Then, we can just dispatch as follows:","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"spank(x) = spank(flyswimtrait(x), x)\nspank(::CanFlySwim, x) = \"Flying high and diving deep\"\nspank(::CannotFlySwim, x) = \"Too Bad\"","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"Magically, since a duck can fly and swim, it can be dispatched as such:","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"spank(Duck())   # \"Flying high and diving deep\"\nspank(Dog())    # \"Too Bad\"","category":"page"},{"location":"guide/#How-does-it-work?-1","page":"User Guide","title":"How does it work?","text":"","category":"section"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"The underlying machinery is extremely simple. Using the above example, when you define a traits like @trait Fly as Ability, it literally expands to the following code:","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"abstract type FlyTrait <: Ability end\nstruct CanFly <: FlyTrait end\nstruct CannotFly <: FlyTrait end\nflytrait(x) = CannotFly()","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"As you can see, our opinion is to define a new abstract type called  FlyTrait.  Likewise, we define CanFly and CannotFly subtypes.  Finally, we define a default trait function flytrait that just returns an instance of CannotFly.  Hence, all data types are automatically disqualified from the trait by default.","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"Now, when you do @assign Duck with Fly,Swim, it is just translated to:","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"flytrait(::Duck) = CanFly()\nswimtrait(::Duck) = CanSwim()","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"Making composite traits is slightly more interesting.  It creates a new trait by combining multiple traits together.  Having a composite trait is defined as one that exhibits all of the underlying traits.  Hence, @trait FlySwim as Ability with Fly,Swim would be translated to the following:","category":"page"},{"location":"guide/#","page":"User Guide","title":"User Guide","text":"abstract type FlySwimTrait <: Ability end\nstruct CanFlySwim <: FlySwimTrait end\nstruct CannotFlySwim <: FlySwimTrait end\n\nfunction flyswimtrait(x)\n    if flytrait(x) === CanFly() && swimtrait(x) === CanSwim()\n        CanFlySwim()\n    else\n        CannotFlySwim()\n    end\nend","category":"page"},{"location":"intro/#Example:-tickling-a-duck-and-a-dog-1","page":"Introduction","title":"Example: tickling a duck and a dog","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Suppose that we are modeling the ability of animals.  So we can define traits as follows:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"abstract type Ability end\n@trait Swim as Ability\n@trait Fly as Ability","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Consider the following animal types:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"struct Dog end\nstruct Duck end","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"We may want to assign them traits:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"@assign Dog with Swim\n@assign Duck with Swim,Fly","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Then, you can just do multiple dispatch as usual:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"tickle(x) = tickle(flytrait(x), swimtrait(x), x)\ntickle(::CanFly, ::CanSwim, x) = \"Flying high and diving deep\"\ntickle(::CanFly, ::CannotSwim, x) = \"Flying away\"\ntickle(::Ability, ::Ability, x) = \"Stuck laughing\"","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"So it just works:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"tickle(Dog())   # \"Stuck laughing\"\ntickle(Duck())  # \"Flying high and diving deep\"","category":"page"},{"location":"reference/#BinaryTraits-1","page":"Reference","title":"BinaryTraits","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Macros-1","page":"Reference","title":"Macros","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"@trait\n@assign\n@implement\n@check","category":"page"},{"location":"reference/#BinaryTraits.@trait","page":"Reference","title":"BinaryTraits.@trait","text":"@trait <name> [as <category>] [prefix <positive>,<negative>] [with <trait1,trait2,...>]\n\nCreate a new trait type for name called $(name)Trait.\n\nIf the as clause is provided, then category (an abstract type) will be\n\nused as the super type of the trait type.\n\nIf the prefix clause is provided, then it allows the user to choose different\n\nprefixes than the default ones (Can and Cannot) e.g. prefix Is,Not or prefix Has,Not.\n\nIf the with clause is provided, then it defines a composite trait from existing\n\ntraits. Note that you must specify at least 2 traits to make a composite trait.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#BinaryTraits.@assign","page":"Reference","title":"BinaryTraits.@assign","text":"@assign <T> with <Trait1, Trait2, ...>\n\nAssign traits to the data type T.  For example:\n\n    @assign Duck with Fly,Swim\n\nis translated to something like:\n\n    flytrait(::Duck) = CanFly()\n    swimtrait(::Duck) = CanSwim()\n\nwhere x is the name of the trait X in all lowercase, and T is the type being assigned with the trait X.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#BinaryTraits.@implement","page":"Reference","title":"BinaryTraits.@implement","text":"@implement <CanType> by <FunctionSignature>\n\nRegister function signature for the specified CanType of a trait. You can use the @check macro to verify your implementation after these interface contracts are registered.\n\nFor example:\n\n    @implement CanFly by fly(direction::Direction, speed::Float64)\n\n\n\n\n\n","category":"macro"},{"location":"reference/#BinaryTraits.@check","page":"Reference","title":"BinaryTraits.@check","text":"@check <T>\n\nCheck whether the data type T fully implements all of its assigned traits.  Return an InterfaceReview object.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Functions-1","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"istrait","category":"page"},{"location":"reference/#BinaryTraits.istrait","page":"Reference","title":"BinaryTraits.istrait","text":"istrait(x)\n\nReturn true if x is a trait type e.g. FlyTrait is a trait type when it is defined by a statement like @trait Fly.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Types-1","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"InterfaceReview","category":"page"},{"location":"reference/#BinaryTraits.InterfaceReview","page":"Reference","title":"BinaryTraits.InterfaceReview","text":"InterfaceReview\n\nAn InterfaceReview object contains the validation results of an interface.\n\n\n\n\n\n","category":"type"}]
}
