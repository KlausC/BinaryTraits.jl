var documenterSearchIndex = {"docs":
[{"location":"#","page":"-","title":"-","text":"Modules = [BinaryTraits]\nOrder   = [:constant, :macro, :function, :type]","category":"page"},{"location":"#BinaryTraits.@assign-Tuple{Symbol,Symbol,Union{Expr, Symbol}}","page":"-","title":"BinaryTraits.@assign","text":"@assign <T> with <Trait1, Trait2, ...>\n\nAssign traits to the data type T.  Translated to something like:\n\n    <x>trait(::T) = Can<X>()\n\nwhere x is the name of the trait X in all lowercase, and T is the type being assigned with the trait X.\n\n\n\n\n\n","category":"macro"},{"location":"#BinaryTraits.@check-Tuple{Any}","page":"-","title":"BinaryTraits.@check","text":"@check <Type>\n\nCheck whether the data type T fully implements all of its assigned traits.  Return a named tuple with the following attributes:\n\nfully_implemented: Bool\nmissing_contracts: Contract[]\n\n\n\n\n\n","category":"macro"},{"location":"#BinaryTraits.@implement-Tuple{Any,Any,Any}","page":"-","title":"BinaryTraits.@implement","text":"@implement <CanType> by <FunctionSignature>\n\nRegister function signature for the specified CanType of a trait.\n\n\n\n\n\n","category":"macro"},{"location":"#BinaryTraits.@trait-Tuple{Symbol,Vararg{Any,N} where N}","page":"-","title":"BinaryTraits.@trait","text":"@trait <name> [as <category>] [prefix <positive>,<negative>] [with <trait1,trait2,...>]\n\nCreate a new trait type for name called $(name)Trait.\n\nIf the as clause is provided, then category (an abstract type) will be\n\nused as the super type of the trait type.\n\nIf the prefix clause is provided, then it allows the user to choose different\n\nprefixes than the default ones (Can and Cannot) e.g. prefix Is,Not or prefix Has,Not.\n\nIf the with clause is provided, then it defines a composite trait from existing\n\ntraits. Note that you must specify at least 2 traits to make a composite trait.\n\n\n\n\n\n","category":"macro"},{"location":"#BinaryTraits.istrait-Tuple{DataType}","page":"-","title":"BinaryTraits.istrait","text":"istrait(x)\n\nReturn true if x is a trait.  This function is expected to be extended by users for their trait types.  The extension is automatic when the @trait macro is used.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.InterfaceReview","page":"-","title":"BinaryTraits.InterfaceReview","text":"InterfaceReview\n\nAn InterfaceReview object contains the validation results of an interface.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryTraits.Assignable","page":"-","title":"BinaryTraits.Assignable","text":"The Assignable type represents any data type that can be associated with traits.  For example, a Duck type is Assignable and so it may be assigned with traits CanFly and CanSwim.\n\nThe reason why it includes UnionAll is to support parametric types that are not fully qualified e.g. AbstractArray.\n\n\n\n\n\n","category":"constant"},{"location":"#BinaryTraits.interface_map","page":"-","title":"BinaryTraits.interface_map","text":"interface_map\n\nThe interface_map is a two-layer Dict data structure. It maps a module to another Dict that maps a data type to a set of Contracts.\n\nFor example, a Duck\n\n\n\n\n\n","category":"constant"},{"location":"#BinaryTraits.prefix_map","page":"-","title":"BinaryTraits.prefix_map","text":"The prefix_map is a Dict that maps a module to another Dict, which maps a trait (as a Symbol) to tuple of positive and negative prefixes for the trait type.  For example:\n\nMain -> :Fly -> (:Can, :Cannot)\n\n\n\n\n\n","category":"constant"},{"location":"#BinaryTraits.traits_map","page":"-","title":"BinaryTraits.traits_map","text":"The traits_map is a two-layer Dict.  First layer is to map from a module to data types that have been assigned with traits.  The second layer maps a data type to the Can-type of the asigned traits.\n\nFor example, a user module ZooKeeper may define Duck and Dog types and then assign them with Fly and Swim traits.  The map would look like this:\n\njulia> BinaryTraits.traits_map[ZooKeeper]\nDict{Union{DataType, UnionAll},Set{DataType}} with 2 entries:\n  Dog  => Set(DataType[CanSwim])\n  Duck => Set(DataType[CanSwim, CanFly])\n\n\n\n\n\n","category":"constant"},{"location":"#BinaryTraits.assign-Tuple{Module,Union{DataType, UnionAll},DataType}","page":"-","title":"BinaryTraits.assign","text":"assign(m::Module, T::Assignable, can_type::DataType)\n\nAssign data type T with the specified Can-type of a trait.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.contracts-Tuple{Module,DataType}","page":"-","title":"BinaryTraits.contracts","text":"contracts(m::Module, can_type::DataType)\n\nReturns a set of Contracts that are required to be implemented for can_type.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.display_expanded_code-Tuple{Expr}","page":"-","title":"BinaryTraits.display_expanded_code","text":"display_expanded_code(expr::Expr)\n\nDisplay the expanded code from a macro for debugging purpose. Only works when the verbose flag is set using set_verbose.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.fully_implemented-Tuple{Module,Union{DataType, UnionAll}}","page":"-","title":"BinaryTraits.fully_implemented","text":"fully_implemented(m::Module, T::Assignable)\n\nCheck if the data type T defined in module m has fully implemented all trait functions that it was previously assigned.  See also: @assign.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.get_prefix-Tuple{Module,Symbol}","page":"-","title":"BinaryTraits.get_prefix","text":"Get trait type positive/negative prefixes for trait.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.is_tuple_of_symbols-Tuple{Any}","page":"-","title":"BinaryTraits.is_tuple_of_symbols","text":"Check if x is an expression of a tuple of symbols. If n is specified then also check whether the tuple has n elements. The op argument is used to customize the check against n. Use >= or <= to check min/max constraints.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.parse_trait_args-Tuple{Any}","page":"-","title":"BinaryTraits.parse_trait_args","text":"Parse arguments for the @trait macro.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.register-Union{Tuple{N}, Tuple{Module,DataType,Function,Tuple{Vararg{DataType,N}}}, Tuple{Module,DataType,Function,Tuple{Vararg{DataType,N}},Union{Nothing, DataType}}} where N","page":"-","title":"BinaryTraits.register","text":"register(m::Module, can_type::DataType, func::Function,\n         args::NTuple{N,DataType}, ret::DataType)\n\nRegister a function func with the specified can_type type. The func is expected to take arguments args and return a value of type ret.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.set_prefix-Tuple{Module,Symbol,Tuple{Symbol,Symbol}}","page":"-","title":"BinaryTraits.set_prefix","text":"Set trait type positive/negative prefixes for trait.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.trait_func_name-Tuple{Any}","page":"-","title":"BinaryTraits.trait_func_name","text":"trait_func_name(t)\n\nReturn the name of the trait instropectin function given a trait t. For example, it would be flytrait for a Fly trait.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.trait_type_name-Tuple{Any}","page":"-","title":"BinaryTraits.trait_type_name","text":"trait_type_name(t)\n\nReturn the name of trait type given a trait t. For example, it would be FlyTrait for a Fly trait. The trait is expected to be in TitleCase, but this function automatically convert the first character to upper case regardless.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.traits-Tuple{Module,Union{DataType, UnionAll}}","page":"-","title":"BinaryTraits.traits","text":"traits(m::Module, T::Assignable)\n\nReturns a set of Can-types that the data type T exhibits. See also @assign.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryTraits.Contract","page":"-","title":"BinaryTraits.Contract","text":"Contract\n\nA contract refers to a function defintion func that is required to satisfy the Can-type of a trait. The function func must accepts args and returns ret.\n\n\n\n\n\n","category":"type"}]
}
