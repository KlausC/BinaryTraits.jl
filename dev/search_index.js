var documenterSearchIndex = {"docs":
[{"location":"#BinaryTraits-1","page":"BinaryTraits","title":"BinaryTraits","text":"","category":"section"},{"location":"#","page":"BinaryTraits","title":"BinaryTraits","text":"","category":"page"},{"location":"#Macros-1","page":"BinaryTraits","title":"Macros","text":"","category":"section"},{"location":"#","page":"BinaryTraits","title":"BinaryTraits","text":"@trait\n@assign\n@implement\n@check","category":"page"},{"location":"#BinaryTraits.@trait","page":"BinaryTraits","title":"BinaryTraits.@trait","text":"@trait <name> [as <category>] [prefix <positive>,<negative>] [with <trait1,trait2,...>]\n\nCreate a new trait type for name called $(name)Trait.\n\nIf the as clause is provided, then category (an abstract type) will be\n\nused as the super type of the trait type.\n\nIf the prefix clause is provided, then it allows the user to choose different\n\nprefixes than the default ones (Can and Cannot) e.g. prefix Is,Not or prefix Has,Not.\n\nIf the with clause is provided, then it defines a composite trait from existing\n\ntraits. Note that you must specify at least 2 traits to make a composite trait.\n\n\n\n\n\n","category":"macro"},{"location":"#BinaryTraits.@assign","page":"BinaryTraits","title":"BinaryTraits.@assign","text":"@assign <T> with <Trait1, Trait2, ...>\n\nAssign traits to the data type T.  For example:\n\n    @assign Duck with Fly,Swim\n\nis translated to something like:\n\n    flytrait(::Duck) = CanFly()\n    swimtrait(::Duck) = CanSwim()\n\nwhere x is the name of the trait X in all lowercase, and T is the type being assigned with the trait X.\n\n\n\n\n\n","category":"macro"},{"location":"#BinaryTraits.@implement","page":"BinaryTraits","title":"BinaryTraits.@implement","text":"@implement <CanType> by <FunctionSignature>\n\nRegister function signature for the specified CanType of a trait. You can use the @check macro to verify your implementation after these interface contracts are registered.\n\nFor example:\n\n    @implement CanFly by fly(direction::Direction, speed::Float64)\n\n\n\n\n\n","category":"macro"},{"location":"#BinaryTraits.@check","page":"BinaryTraits","title":"BinaryTraits.@check","text":"@check <T>\n\nCheck whether the data type T fully implements all of its assigned traits.  Return an InterfaceReview object.\n\n\n\n\n\n","category":"macro"},{"location":"#Functions-1","page":"BinaryTraits","title":"Functions","text":"","category":"section"},{"location":"#","page":"BinaryTraits","title":"BinaryTraits","text":"istrait","category":"page"},{"location":"#BinaryTraits.istrait","page":"BinaryTraits","title":"BinaryTraits.istrait","text":"istrait(x)\n\nReturn true if x is a trait type e.g. FlyTrait is a trait type when it is defined by a statement like @trait Fly.\n\n\n\n\n\n","category":"function"},{"location":"#Types-1","page":"BinaryTraits","title":"Types","text":"","category":"section"},{"location":"#","page":"BinaryTraits","title":"BinaryTraits","text":"InterfaceReview\nAssignable\nContract","category":"page"},{"location":"#BinaryTraits.InterfaceReview","page":"BinaryTraits","title":"BinaryTraits.InterfaceReview","text":"InterfaceReview\n\nAn InterfaceReview object contains the validation results of an interface.\n\n\n\n\n\n","category":"type"}]
}
